import os

import pytest
from faker import Faker
from sqlalchemy import create_engine, func
from sqlalchemy.orm import Session

from script_files.db_manager import Base, Child,  User
from script_files.db_manager import DataBaseManager

fake = Faker()

@pytest.fixture(scope='session')
def engine():
    return create_engine('sqlite:///:memory:')


@pytest.fixture(scope='session')
def tables(engine):
    Base.metadata.create_all(engine)
    yield
    Base.metadata.drop_all(engine)


@pytest.fixture
def session(engine, tables):
    ''' Returns an sqlalchemy session, 
    and after the test tears down everything properly.'''
    connection = engine.connect()
    # this metod uses nested transaction, and already started transaction
    transaction = connection.begin()
    session = Session(bind=connection)

    yield session

    session.close()
    # roll back the broader transaction
    transaction.rollback()
    connection.close()


@pytest.fixture
def user_data():
    '''
    Fake data generated by Faker 
    '''
    user_data = {
        'firstname': fake.first_name(),
        'telephone_number': fake.phone_number(),
        'email': fake.email(),
        'password': fake.password(),
        'role': fake.random_element(['admin', 'user']),
        'created_at': fake.date_time_this_decade(),
        'created_at': '2023',
        'children' : []
    }
    return user_data


@pytest.fixture
def child_data():
    
    child_data = {
        'user_id': 10,
        'name': fake.first_name(),
        'age': 5
    }
    return child_data


def test_child_class(session, child_data):
    '''
    Simple test for creating the Child class instance
    '''
    child = Child(**child_data)
    
    session.add(child)
    session.commit()

    result = session.query(Child).filter_by(name=child_data['name']).first()

    assert result is not None
    assert result.user_id == child_data['user_id']
    assert result.name == child_data['name']
    assert result.age == child_data['age']


def test_user_class(session, user_data):

    user = User(user_data)

    session.add(user)
    session.commit()

    result = session.get(User, 1)

    assert result is not None
    assert result.firstname == user_data['firstname']
    assert result.telephone_number == user_data['telephone_number']
    assert result.email == user_data['email']
    assert result.password == user_data['password']
    assert result.role == user_data['role']
    assert result.created_at == user_data['created_at']


def test_create_database(session):
    '''
    Function test if database can be created
    '''
    test_data = [
        {
            'firstname': 'Test', 
            'telephone_number': '123456789', 
            'email': 'test@example.com', 
            'password': 'password', 
            'role': 'user', 
            'created_at': '2023-01-01'
        },
        
    ]

    result = DataBaseManager.create_database(test_data)

    assert result == 'Database created'


def test_return_data_path():
    
    result = DataBaseManager.return_data_path()
    assert os.path.exists(result)


def test_return_db_path():
    
    result = DataBaseManager.return_db_path()
    assert os.path.exists(result)


def test_data_validator():
    
    result = DataBaseManager.data_validator()

    assert isinstance(result, list)
    for item in result:
        assert 'firstname' in item
        assert 'telephone_number' in item
        assert 'email' in item
        assert 'password' in item
        assert 'role' in item
        assert 'created_at' in item


def test_db_switcher():
    
    session = DataBaseManager.db_switcher()
    user_count = session.query(func.count(User.id)).scalar()

    assert session is not None
    assert isinstance(session, Session)
    assert session.bind is not None
    assert user_count >= 0

    session.close()